[TOC]

# <div align = "center">OO规格化设计总结</div>

## **一、本单元测试过程**

### **1.1 对黑箱测试、白箱测试的理解**

* 黑箱测试：是一种“站在**用户角度**”的测试方法，每一个待测试的模块对于我们来说都是一个内部结构未知的“黑盒”。将测试的程序看作是一个不公开透明的黑色盒子，不考虑盒子里面的逻辑结果跟程序运行，只是根据程序的需求规格书来检查程序的功能是否符合它的功能说明，检验输入数据所对应的输出结果是否正确。这种测试方法主要用于测试程序的`功能性`，通过构造大量的测试数据，来检验某个函数是否能满足其所要实现的功能，而忽略内部实现的细节。课程网站的评测机及OKTest方法都是黑箱测试
* 白箱测试：也叫`结构测试`，每一个待测试的模块对于我们来说都是内部结构完全已知的“白盒”。通过在不同点检查程序状态，检验程序中的每条通路是否都能按预定要求进行正确工作。需要对待测模块内部的实现代码进行详细的检查，确保代码的运行逻辑不存在任何疏漏。我们在给程序debug时的单步调试就是白箱测试

### **1.2 单元测试、功能测试、集成测试、压力测试、回归测试**

* **单元测试**：对软件中最小可测试单元进行检查和验证。在这种情况下，某个软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。在本单元作业中，主要体现为对各个函数功能的测试，如添加人、添加组、添加消息、qlm的测试等
* **功能测试**：对程序的**功能正确性**进行测试，检测系统是否能够正确地接受输入、执行操作并产生预期的输出，以确保系统的功能性符合要求，类似于黑箱测试
* **集成测试**：主要用于测试不同模块、组件或子系统之间的接口和交互是否能够正常工作。通过单元测试可以保证每个单元模块都能够正常工作，但耦合到一起进行运转可能会出现问题，可以帮助发现模块之间的集成问题、接口错误和数据传递问题，因此集成测试也是必不可少的
* **压力测试**：通过模拟大量并发用户、高负载或超过正常预期的工作负载，评估系统在这种条件下的性能和稳定性，以确定系统在压力下是否能够正常运行，通俗地来说，压力测试就是让软件去适应极端恶劣的情况，比如大量边界数据、重复数据等，比较容易发现问题
* **回归测试**：主要用于测试软件原有功能在修改后是否保持完整，比如每次作业满足新的迭代要求后原来的功能是否还能够得到满足

### **1.3 测试工具**

​		本单元的测试中，我通过将自己的代码与同学的代码进行对拍来debug。正确性检验比较难以开发，但对拍器比较容易实现，先使用数据生成器生成测试用例，之后把用例在自己和别人的程序都跑一遍，跑完以后对比输出

​		测试时主要针对复杂度比较高的指令进行测试。比如qlm指令，由于无法进行动态维护，因此时间复杂度比较高，需要对其进行充分的测试，进行优化

## 二、架构设计

### **2.1 并查集**

​		在NetWork类中用HashMap存储各个人的祖宗节点，在添加关系、删除关系时需要维护并查集，添加关系时将该关系存入HashMap中即可，查找时进行路径压缩；删除关系时比较麻烦，需要先判断要删除的两个点在删掉边之后是否仍然可达，若仍然可达，则不需要进行维护；若不可达，则在两个点分别开始进行路径压缩，将其经过的点的祖宗节点均设为这两个点，这样就构造出了两颗树，具体实现如下：

```java
if (!bfs(id1, id2)) { // bfs用于判断id1是否可达id2，在搜索的过程中会将id1经过的点的祖宗节点均设为id1
                    fathers.put(id1, id1);
                    fathers.put(id2, id2);
                    bfsMerge(id2); // id1与id2不可达，将id2可达的点的祖宗节点均设为id2
                }
```

### **2.2 最短路径树**

​		我一开始qlm所用的算法是Dijkstra删边法，测试之后发现可能会超时，于是我换成了讨论区大佬们提到的**最短路径树**方法，时间复杂度相对来说比较低，可以过强测，具体实现如下：

```java
// 删边法：
for (Person person : cpAcq.values()) {
    // 删掉与此person间的边
    // 运用dijkstra算法求与此person是否存在最短路
    // 更新ans
     // 恢复删掉的边
}
// 最短路径树：
public static int qlm(int id, HashMap<Integer, Person> people) {
        MyNetwork2.people = people;
        res.clear();
        HashMap<Integer, Integer> res = dijsktra(id);
        return res.get(id);
}
```

### **2.3 动态维护**

* qbs可以动态维护，每次查询时遍历fathers HashMap中key与value相等点的数量即可，复杂度为O(n)，实现如下：

```java
public int queryBlockSum() { // 求连通块
    int blockSum = 0;
    for (Integer x : fathers.keySet()) {
        if (fathers.get(x).equals(x)) {
            blockSum++;
        }
    }
    return blockSum;
}
```

* qts可以动态维护，添加关系、删除关系时进行维护，如果id1的熟人也是id2的熟人，那么triSum++或者--

```java
	for (Person item : ((MyPerson) temp).getAcquaintance().values()) {
            if (item.isLinked(getPerson(u))) {
                if (type == 1) {
                    tripleSum++;
                } else {
                    tripleSum--;
                }
            }
    }
```

* qcs：在MyPerson类中添加了一个BestAcq属性，用于存储每个人的关系最好的人的ID，查询couple数量时对people列表进行O(n)遍历，如果这个人的最好的人的最好的人的id也是这个人，那么coupleSum++
* qgvs：在MyPerson类中添加了一个HashMap<Integer, Group> groups 属性，用于存储每个人所在的组，在添加、修改、删除关系时动态维护每个组的valueSum，具体实现如下：

```java
public void modGroupVal(int id1, int id2, int value) {
        Person person1 = getPerson(id1);
        Person person2 = getPerson(id2);
        for (Integer key : ((MyPerson) person1).getGroups().keySet()) {         // 遍历id1所在的组号
            if (((MyPerson) person2).getGroups().containsKey(key)) { // 如果id2恰好也在这个组
                ((MyGroup) ((MyPerson) person1).getGroups().get(key)).addValueSum(2 * value);
                						 // 进行维护
            }
        }
    }
```

* qgav：在MyGroup中添加sumAge和sumAgeSquare属性，每次addToGroup、delFromGroup时进行维护

## **三、性能与修复、规格与实现分离**

### **3.1 性能与bug修复**

* 第9次作业中，对于qbs和qci我是直接采用的宽度优先搜索，时间复杂度过高，导致强测t了两个点，在修复时改为用并查集来实现就解决了
* 第10次作业中，由于自己的一时大意，动态维护qgvs指令在组中删人的时候忘记对其进行更新，t了两个点
* 第11次作业中，对于qlm指令采用Dijkstra + 删边法来实现，强测点4超时了，改为最短路径树实现即可满足时间复杂度要求

### **3.2 规格与实现分离的理解**

​		规格就是一种约束，一种要求，比如一个客户给你提了一个要求，你只要来实现这个功能即可，至于内部的耦合逻辑别人并不关心，客户关心的只是你能精确无误高性能的实现我要的功能，有点类似于接口；而具体功能如何实现则是程序员的视角，其负责实现性能高的代码即可

​		规格与实现的分离有利于客户与程序员站在各自立场来沟通，高效的实现功能的提出和迭代

## 四、OK测试

​		当我们实现所要求的功能后，需要证明我们所实现的功能遵照了规格所描述的要求，需要判断具体实现是否满足规格对`函数调用前后状态变化`的描述和`函数输出结果`的描述，以及异常情况下的处理。在本单元作业里我们需要对规格中的ensures语句逐个进行检验，确保每条ensures语句都得到了实现

​		我建议将oktest放在一个单独的类中，我认为这样可以更好的帮助我们理解OK测试，更符合面向对象的思想

## 五、学习体会

​		这单元的难度相较于前两个单元降低了一点点，但还是不容忽视的，每次作业还是要投入大量时间来完成的。

​		一方面，学习到了规格设计的严谨，对于编程来说消除了二义性，更加规范；另一方面，学习到了许多关于图论的算法，包括并查集、最短路径树等算法，对于时间复杂度有了进一步的认识，收获颇丰
