# <div align = "center">OO第一单元总结</div>

## 一、程序结构分析

### 1.1 HW1

#### 1.1.1 构建思路描述

本次作业除了MainClass外，实现了十个类加一个Facter接口。我的设计思路如下：

 	1. 首先采用递归下降的方法分析输入表达式，得到后缀表达式，再利用Simplify类进行计算、化简、合并，最后得到一个Poly类的对象，里面包含了每一项的系数与三个变量的指数，最后通过toString（）输出即可。
 	2. 我是通过训练栏目获得的思路，得到的后缀表达式每读到一个运算符就按照运算符的逻辑关系将其前两项进行运算即可，Poly即多项式类里实现了add、sub、mul方法，VaryPow即项类里实现了项与项之间的add、sub、mul方法和判断两个项是否能够合并的judge方法，这样在进行表达式和表达式之间的运算时直接调用项与项之间的运算方法即可完成。

​	我的后两次作业也是基于分析后缀表达式从而得到a*x**(x的系数)*y**(y的系数)*z**(z的系数)形式的项（VaryPow），再通过Poly间的运算进行处理的方法。

#### 1.1.2 UML图

#### 1.1.3 类复杂图

#### 1.1.4 方法复杂图

### 1.2 HW2

#### 1.2.1 构建思路描述

​		第二次比第一次多了三角函数sin和cos，还有自定义函数。基于第一次作业的框架，这次只需要在项VaryPow里加一个三角函数的内容即可，得到a*x*y*z*sin*cos的形式；新加一个自定义函数类，先递归下降将表达式里的自定义函数全都replace，再递归下降处理之后得到的不含自定义函数的表达式得到后缀表达式进行计算即可，此时就回到了第一次作业的流程。

​		但是这次作业我没有充分考虑架构的可扩展性，比如我在VaryPow里加三角函数内容的时候是直接用字符串表示了，HashMap<String, BigInteger> String即为sin（）或者cos（），BigInteger为系数，这也导致我在第三次作业需要对三角函数求导的时候无处下手，只能被迫小型重构。

#### 1.2.2 UML图

#### 1.2.3 类复杂图

#### 1.2.4 方法复杂图

### 1.3 HW3

#### 1.3.1 构建思路描述

​		由于我在第二次作业实现上偷了懒，没有充分考虑到架构的可迭代性，导致我被迫进行小范围的重构。这次作业我在实现三角函数项时，HashMap<Poly, Pair<BigInteger, Boolean>>来存储三角函数项，这样即可实现对三角函数嵌套形式的求导，Poly是该三角函数括号里的内容，Boolean是0代表是sin，1代表cos，另一个是系数，而且该种形式方便进行三角函数的优化合并。

​		而在第二次作业我对自定义函数也是直接进行String层次的拆分，没有考虑到这次的自定义函数中调用自定义函数，所以变换了处理策略：即将自定义函数读取时也利用递归下降来分析，进行代换，这样就可以在第二次架构的基础上直接在表达式中进行代换。

​		我在VaryPow和Poly两个类里均实现了求导方法，这样VaryPow的三角函数对其含有的Poly求导就可以调用Poly的求导方法，而Poly求导就可以分别对其中含有的每一项VaryPow求导然后相加即可，这种相互调用进行求导体现了层次化思想.

#### 1.3.2 UML图

#### 1.3.3 类复杂图

#### 1.3.4 方法复杂图

## 二、Bug分析

​		第一次作业：由于我一时疏忽，在处理数字时有一处使用的是Long类型存储，最后忘记更改成BigInteger，导致互测时被大数hack；还有在多项式和多项式进行加法运算时，没有处理“爆0”，即如果运算之后是0就不应该添加到我们的结果中，因为最后可能会因为结果中出现大量的“0”而超时，所以特判一下即可。

​		第二次作业：这次作业被hack的有点惨，被hack了15处，但还好最后修复其实就是两处bug：

1.   忽略了称号* 和 **的优先级，在识别出\*或者**后应在项的两边加上括号，否则容易出现计算顺序错误的问题，所以在两边加上括号即可fix；
2.   由于三角函数的出现，我在第一次架构中忘记了两个多项式加完之后是0的问题，导致最后可能出现两个多项式运算玩之后如果是0可能得到的结果是一个空的多项式，即里面什么都没有，如果没有三角函数这影响不到我的最终结果，因为最后在输出时如果长度为0会直接输出0，但是存在sin和cos可能就会出现sin()和cos()的情况，从而出现形式错误。

​		第三次作业由于前两次作业被hack发现的bug太多了，导致第三次没有出现bug。

## 三、hack策略

​		通过阅读他人代码可以学习一些扩展性好的架构，也可以发现一下比较明显的bug，比如有些同学数字的存储没有使用BigInteger，三角函数在优化时可能忽略一些系数和指数的处理，还有一些边界数据的问题。

## 四、架构设计体验

​		本单元作业我体会到了面向对象式的层次化设计在处理复杂工程中的优越的可扩展性，递归下降在处理表达式问题的优越性。第一次作业虽然没有括号的嵌套，但是通过递归下降解析就可以应付之后的不同形式的嵌套问题，比如三角函数嵌套、自定义函数嵌套，递归下降就是解决这类问题的“通法”，不论形式有多复杂，都可以递归下降一步步解析出他应有的层次。

​		我的架构是在三次作业中一步步走向成熟的。首先从控制台读入表达式后，先进行预处理，去除空白符和连续的"+"或"-"，或者多余的"+"；然后传入Lexer和Parser进行递归下降解析，最后得到一个Expr类的对象，即后缀表达式，然后利用Simplify类进行运算，Poly类(多项式)里面有个VaryPow(项)的ArrayList容器，最后得到一个Poly类的对象，toString()输出即可；

​		第二次作业出现了三角函数和自定义函数，则新添三角函数类实现Factor接口，自定义函数实现Factor接口，参与到表达式的解析；然后对于自定义函数，我的处理是先递归下降处理自定义函数得到不含将其替换，然后再递归下降处理得到的表达式，然后就变成了第一次作业的处理流程，因此这次作业只需在第一次作业的基础上加两个实现了Factor接口的类即可；

​		第三次作业出现了求导和自定义函数中调用其他自定义函数，只需要把Varypow里的三角函数容器换下形式、并分别在VaryPow和Poly里实现求导方法即可；而自定义函数也按照递归下降的流程replace一下即可，所以总的来说没有重构什么，由于递归下降的可扩展性，使得我在这三次作业都是一步一步在前一个架构上加一点东西就实现了。

## 五、心得体会

​		本单元作业我初步体会到了面向对象设计方法的好处,在面对未知的迭代任务时,建立一个好的架构对于日后的工作可以说是事半功倍.第一次作业由于训练栏目给的启发采用了递归下降的方法来处理表达式得到后缀表达式再进行计算,从而在接下来的两次作业中能够完成增量开发.因此,建立一个好的架构不仅可以减少bug数量,也方便进行优化开发.
